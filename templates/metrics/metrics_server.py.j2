#!/usr/bin/env python3
from http.server import BaseHTTPRequestHandler, HTTPServer
import json, time

last_total = None
last_idle = None

def read_cpu():
    global last_total, last_idle
    with open('/proc/stat','r') as f:
        line = f.readline()
    parts = line.split()
    if parts[0] != 'cpu':
        return 0.0
    vals = list(map(int, parts[1:]))
    user, nice, system, idle, iowait, irq, softirq, steal, *_ = vals + [0]*(10-len(vals))
    idle_all = idle + iowait
    non_idle = user + nice + system + irq + softirq + steal
    total = idle_all + non_idle
    if last_total is None or last_idle is None:
        last_total, last_idle = total, idle_all
        time.sleep(0.25)
        with open('/proc/stat','r') as f:
            line = f.readline()
        parts = line.split()
        vals = list(map(int, parts[1:]))
        user, nice, system, idle, iowait, irq, softirq, steal, *_ = vals + [0]*(10-len(vals))
        idle_all2 = idle + iowait
        non_idle2 = user + nice + system + irq + softirq + steal
        total2 = idle_all2 + non_idle2
        totald = total2 - total
        idled = idle_all2 - idle_all
        last_total, last_idle = total2, idle_all2
        if totald <= 0:
            return 0.0
        return max(0.0, min(100.0, (totald - idled) * 100.0 / totald))
    totald = total - last_total
    idled = idle_all - last_idle
    last_total, last_idle = total, idle_all
    if totald <= 0:
        return 0.0
    return max(0.0, min(100.0, (totald - idled) * 100.0 / totald))

def read_mem():
    info = {}
    with open('/proc/meminfo','r') as f:
        for line in f:
            k,v,*_ = line.split()
            info[k.rstrip(':')] = int(v)
    total = info.get('MemTotal', 0) * 1024
    avail = info.get('MemAvailable', 0) * 1024
    used = max(0, total - avail)
    used_pct = (used / total * 100.0) if total else 0.0
    return total, used, used_pct

def read_load():
    with open('/proc/loadavg','r') as f:
        parts = f.read().split()
    return tuple(map(float, parts[:3]))

def read_uptime():
    with open('/proc/uptime','r') as f:
        return float(f.read().split()[0])

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path.startswith('/metrics'):
            cpu = read_cpu()
            mt, mu, mp = read_mem()
            l1,l5,l15 = read_load()
            up = read_uptime()
            data = {
                'cpu_percent': round(cpu,2),
                'mem': {
                    'total': mt,
                    'used': mu,
                    'used_percent': round(mp,2)
                },
                'loadavg': {'1': l1, '5': l5, '15': l15},
                'uptime_seconds': int(up)
            }
            payload = json.dumps(data).encode('utf-8')
            self.send_response(200)
            self.send_header('Content-Type','application/json')
            self.send_header('Cache-Control','no-store')
            self.end_headers()
            self.wfile.write(payload)
        else:
            self.send_response(404)
            self.end_headers()

def main():
    server = HTTPServer(('127.0.0.1', 9100), Handler)
    server.serve_forever()

if __name__ == '__main__':
    main()
